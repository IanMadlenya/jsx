#
# Copyright (c) 2011 - 2015 ASPECTRON Inc.
# All Rights Reserved.
#
# This file is part of JSX (https://github.com/aspectron/jsx) project.
#
# Distributed under the MIT software license, see the accompanying
# file LICENSE
#
import subprocess
import os
import sys
import shutil
import itertools
import glob
import urllib
import argparse
import tarfile
import multiprocessing
import patch


def parse_args(parser=None):
    if not parser:
        parser = argparse.ArgumentParser()
    parser.add_argument('--gyp-file', dest='gyp_file',
                        help='Project .gyp file to build')
    parser.add_argument('--jsx-root', dest='jsx_root',
                        help='JSX project directory')
    parser.add_argument('--generator-output', dest='generator_output', default='',
                        help='Directory to store project files generated by GYP')
    parser.add_argument('--no-build', dest='nobuild', action='store_true',
                        help='Do not build the project')
    parser.add_argument('--format', dest='format', default=default_project_format(),
                        help='Project format, default is %(default)s',
                        choices=['msvs', 'xcode', 'make', 'ninja', 'cmake'])
    parser.add_argument('--msvc', dest='msvc', default=detect_msvc_version(),
                        help='Visual Studio version if more than one installed, default is %(default)s',
                        choices=installed_msvc_versions())
    parser.add_argument('--config', dest='config', default='Release',
                        help='Debug or Release, default is %(default)s',
                        choices=['Debug', 'Release'])
    parser.add_argument('--platform', dest='platform', default=default_platform(),
                        help='Target platform, default is %(default)s',
                        choices=['x86', 'x64'])
    parser.add_argument('--force', dest='force', action='store_true',
                        help='Force rebuild project')
    parser.add_argument('--force-external', dest='force_external', action='store_true',
                        help='Force rebuild third-party libraries')

    args = parser.parse_args()

    if args.format == 'msvs' and sys.platform == 'win32':
        args.msvc_path = msvc_path(args.msvc)
        if not args.msvc_path:
            sys.exit('Error: Cannot find Visual Studio tools version={}'.format(args.msvc))

    return args


def default_platform():
    return 'x64' if sys.maxsize > 2**32 else 'x86'


def msvc_path(version):
    if version:
        version = version.replace('.', '')
        common_tools_dir = os.environ.get("VS%sCOMNTOOLS" % version)
        if common_tools_dir:
            vc_vars = os.path.join(common_tools_dir, os.pardir, os.pardir, 'VC', 'vcvarsall.bat')
            vc_vars = os.path.normpath(vc_vars)
            if os.path.isfile(vc_vars):
                return vc_vars
    return None


def installed_msvc_versions():
    versions = ['14.0', '12.0', '11.0', '10.0']
    installed = [x for x in versions if msvc_path(x)]
    return installed if installed else None


def detect_msvc_version():
    installed = installed_msvc_versions()
    return installed[0] if installed > 0 else None


def default_project_format():
    format_map = { 'win32': 'msvs', 'darwin': 'xcode' }
    return format_map.get(sys.platform, 'make')


def project_filename(gyp_file, format, out_dir):
    (name, ext) = os.path.splitext(gyp_file)
    path = os.path.dirname(gyp_file)
    if format == 'msvs':
        name += '.sln'
    elif format == 'xcode':
        name += '.xcodeproj'
    elif format == 'ninja':
        name += '.ninja'
    elif format == 'make':
        name = 'Makefile'
    elif args.format == 'cmake':
        name = 'CMakeLists.txt'
    else:
        raise Error('Unknown project format ' + format)
    return os.path.join(path, out_dir, name)

def gyp_format(args):
    format = args.format
    if format == 'msvs':
        version_map = { '10.0': '2010', '11.0': '2012', '12.0': '2013', }
        format += ' -G msvs_version=' + version_map.get(args.msvc, '2010')
    return format


def generate_project(args):
    project = project_filename(args.gyp_file, args.format, args.generator_output)
    print 'Generate {project} from {gyp_file} with jsx_root={jsx_root}'\
        .format(project=project, gyp_file=args.gyp_file, jsx_root=args.jsx_root)

    command = '"{python}" "{gyp_tool}" --depth=. --format={format} --include="{include}" '\
        '--generator-output="{generator_output}" -D jsx="{jsx_root}" "{gyp_file}"' \
        .format(python=sys.executable, format=gyp_format(args),
                gyp_tool=os.path.join(args.jsx_root, 'build', 'tools', 'gyp', 'gyp_main.py'),
                include=os.path.join(args.jsx_root, 'common.gypi'),
                generator_output=args.generator_output,
                jsx_root=args.jsx_root, gyp_file=args.gyp_file)
    execute_sync(command)
    return project


def build_project(args):
    project = generate_project(args)

    if args.nobuild:
        return

    if args.format == 'msvs':
        msbuild_project(args, project)
    elif args.format == 'xcode':
        xcode_project(args, project)
    elif args.format == 'make':
        make_project(args, project)
    elif args.format == 'cmake':
        cmake_project(args, project)
    elif args.format == 'ninja':
        ninja_project(args, project)


def execute_sync(cmd, env=None, check=True):
    if check:
        subprocess.check_call(cmd, shell=True, env=env)
    else:
        subprocess.call(cmd, shell=True, env=env)


def execute_sync_in_msvc_env(args, cmd, env=None):
    vc_arch  = 'x86_amd64' if args.platform == 'x64' else args.platform
    set_env = 'call "{vc_vars}" {vc_arch}'.format(vc_vars=args.msvc_path, vc_arch=vc_arch)
    execute_sync(set_env + ' & ' + cmd, env)


def msbuild_project(args, project):
    platform = 'Win32'     if args.platform == 'x86' else args.platform
    target   = 'Rebuild'   if args.force else 'Build'

    command = 'msbuild /m /p:UseEnv=true /p:Configuration={config} ' \
            '/p:Platform={platform} /t:{target} {project}' \
        .format(config=args.config, platform=platform, target=target, project=project)

    execute_sync_in_msvc_env(args, command)


def xcode_project(args, project):
    command = 'xcodebuild -project {project} -configuration {config}' \
        .format(project=project, config=args.config)
    execute_sync(command)


def make_project(args, project, params=''):
    cwd = os.getcwd()
    project_dir = os.path.dirname(project)
    if project_dir:
        os.chdir(project_dir)
    execute_sync('make -j{num_cpu} {params}'.format(num_cpu=cpu_count(), params=params))
    os.chdir(cwd)


def touch(filename):
    basedir = os.path.dirname(filename)
    if not os.path.isdir(basedir):
        os.makedirs(basedir)
    file = open(filename, 'a')
    os.utime(filename, None)


def copytree(src_dir, dest_dir):
    if not os.path.isdir(dest_dir):
        os.makedirs(dest_dir)
    for path in glob.iglob(src_dir):
        shutil.copy(path, dest_dir)


def movetree(src_dir, dest_dir):
    if not os.path.isdir(dest_dir):
        os.makedirs(dest_dir)
    for path in glob.iglob(src_dir):
        shutil.move(path, dest_dir)


def download_file(url, filename=None):
    def report(blockNumber, blockSize, totalSize):
        currentSize = blockNumber * blockSize
        if totalSize == -1:
            print "\r{} {}".format(filename, currentSize),
        else:
            print "\r{} {}%".format(filename, int(100.0 * currentSize / totalSize)),

    if not filename:
        filename = url.split('/')[-1]
    print 'Downloading ' + url
    urllib.urlretrieve(url, filename, report)
    print


def extract_files(archive):
    print 'Extracting ' + archive + '...'
    tar = tarfile.open(archive, bufsize=20*1024*1024);
    for tar_info in tar:
        tar.extract(tar_info)
        # clear undocumented list of archive members, maintained by the TarFile
        # since this list may be lengthy for large archives
        if len(tar.members) > 10000:
            tar.members = []
    tar.close()


def apply_patches(patches):
    for p in patches:
        file = p.get('file')
        strip = p.get('strip', 0)
        root = p.get('root', None)
        patch.fromfile(file).apply(strip, root)


def cpu_count():
    try:
        return multiprocessing.cpu_count()
    except:
        return 1

def win_libraries(libraries, platform=None):
    platforms = [platform] if platform else ['x86', 'x64']
    return map(lambda (arch, library): arch + '\\' + library,
        itertools.product(platforms, libraries))
